{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dynautomate","text":"<p>Workflows for parametric DOE for LS-DYNA on HPC.  This package is still a work in progress.</p>"},{"location":"#installation","title":"Installation","text":"<p>Package is not available on pip pending full testing.  Repository can be downloaded and installed locally:</p> <pre><code>py -m pip install .\n</code></pre>"},{"location":"#project-overview","title":"Project Overview","text":"<p>The objective of this python package is to provide a set of tools for building workflows to set up parametric LS-DYNA simulations in an HPC environment.  The object structure of the package follows the same structure as the LS-DYNA keyword input files:</p> <pre><code>keyfile\n|-keyword 1\n| |-card 1\n| |-card 2\n| |-card 3\n|-keyword 2\n| |-card 1\n| |-card 2\n|-etc...\n</code></pre>"},{"location":"#parameter-editing","title":"Parameter editing","text":"<p>An initial keyword file is loaded in.  Subsequently, individual keywords and cards can be located and edited or replaced to create new parametric copies of the simulation:</p> <pre><code>\nimport dynautomate as dyna\n\n#load the keyword file\nfile=dyna.KeywordFile(\"/path/to.k\",\"fixed\")\n\n#create a keyword object\nt_term=file.get_keywords(\"CONTROL_TERMINATION\")\n\n#edit a card in the keyword object\nt_term.edit_card(0,0,0.01)\n\n#insert updated keyword into the keyword file\nf.replace_keyword(t_term)\n\n#write new keyword file\nf.write_keyfile(\"/path/to_new.k\")\n\n</code></pre>"},{"location":"#mesh-editing","title":"Mesh editing","text":"<p>In addition to editing properties, basic parametric mesh changes can be performed using transformations:</p> <pre><code>import dynautomate as dyna\n\n#initialize empty transformation operator\ntransform_operator=keyfile.Transformation()\n\n#add translation by 2 in x direction\ntransform_operator.translate(2,0,0)\n\n#add scale y by 5\ntransform_operator.scale(0,5,0)\n\n#rotate by 90 degrees about arbitrary axis\ntransform_operator.rotate([0,0,0],[1,5,6],90)\n\n#import a long format keyword file\nkeyword_file=keyfile.KeywordFile(\"example_keyword.k\",\"long\")\n\n#retrieve nodes\nkeyfile_nodes=keyword_file.get_nodes()\n\n#define node set to be transformed\nnode_set=[0,1,2,3,100]\n\n#apply transformation to nodes\nkeyfile_nodes.transform(node_set,transform_operator)\n\n#write to keyfile and write output\nkeyword_file.replace_keyword(keyfile_nodes)\nkeyword_file.write_keyfile(\"new_keyword.k\")\n\n</code></pre> <p>For details on the full features of each object type, refer to each object documentation page at the top</p>"},{"location":"arraykeyword/","title":"Array Keywords","text":"<p>A special type ofthe keyword object that enables easier editing of the properties of long, list-style keywords such as nodes or elements.  </p>"},{"location":"arraykeyword/#attributes","title":"Attributes","text":"Attribute Type Description self.title String Keyword name self.name String array name (e.g., name of a part set) if applicable, otherwise None self.string String Ascii contents of the keyword self.format String Keyword file type, \"short\" (comma separated), \"fixed\" (standard PrePost format), or \"Long\" (double length PrePost format) self.range list[int] Start and end character index of the keyword self.headercards int Number of control cards prior to list (e.g., ID and solver properties on node sets) self.cards list[Card] List containing header cards self.arrayrange list[int] start and end character of array entries in the keyword self.width int number of entries in each line of the array self.array np.ndarray Array containing the nodal coordinates"},{"location":"arraykeyword/#subclasses","title":"subclasses","text":"<p>All subclasses share the same methods detailed below, but configure a specific type of keyword array with the correct entry widths and number of header cards:</p> <ul> <li>Nodes (node array)</li> <li>Elements (shell, tshell, beam, or solid element array)</li> <li>Set (part, node, or segment set)</li> </ul> <pre><code>\nclass Nodes(ArrayKeyword):\n    headercards=0\n    width=6\n\nclass Elements(ArrayKeyword):\n    headercards=0\n    width=10\n\nclass Set(ArrayKeyword):\n    headercards=1\n    width=8\n\n</code></pre>"},{"location":"arraykeyword/#methods","title":"Methods","text":""},{"location":"arraykeyword/#init","title":"init","text":"<p>Initialize a new array keyword</p> <pre><code>class ArrayKeyword:\n    def __init__(self, input_string: str, input_range: list[int], format:str):\n\nf=KeywordFile(\"/path/to.k\",\"fixed\")\nnodal_coords=f.get_nodes()\n</code></pre> <p>inputs</p> Attribute Type Description input_string String Ascii contents of the keyword format String Keyword file type, \"short\" (comma separated), \"fixed\" (standard PrePost format), or \"Long\" (double length PrePost format) input_range list[int] Start and end character index of the keyword <p>returns</p> <p>Array Keyword object</p>"},{"location":"arraykeyword/#update_string","title":"update_string","text":"<p>Update the contents of self.string to reflect any changes applied</p> <pre><code>def update_string(self):\n\nf=KeywordFile(\"/path/to.k\",\"fixed\")\nnodal_coords=f.get_nodes()\n\nnode_set=[0,1,2,3,4]\n\ntransform_operator=Transformation()\ntransform_operator.scale(2,0,0)\n\nnodal_coords.transform(node_set,transform_operator)\nnodal_coords.update_string()\n\nf.replace_keyword(nodal_coords)\n</code></pre> <p>inputs</p> <p>None</p> <p>returns</p> <p>Updates self.string to reflect changes made.</p>"},{"location":"arraykeyword/#node-class-methods","title":"Node class methods","text":""},{"location":"arraykeyword/#transform","title":"Transform","text":"<p>Applies a pre-defined series of transformations to a set of nodes</p> <pre><code>def transform(self, node_set, operator):\n\nf=KeywordFile(\"/path/to.k\",\"fixed\")\nnodal_coords=f.get_nodes()\n\nnode_set=[0,1,2,3,4]\n\ntransform_operator=Transformation()\ntransform_operator.scale(2,0,0)\n\nnodal_coords.transform(node_set,transform_operator)\n\n</code></pre> <p>inputs</p> Attribute Type Description node_set list[int] indices of each node to apply the transformation to operator Transformation Pre-defined transformation operator containing a specified transformation matrix. <p>returns</p> <p>Updates the nodal array with new x,y,z coordinates for the node subset.</p>"},{"location":"cards/","title":"Cards","text":"<p>The card object stores the data from a single line of values in a keyword.  This is the fundamental unit from which any parametric edits are performed.</p>"},{"location":"cards/#attributes","title":"Attributes","text":"Attribute Type Description self.string String Ascii contents of the keyword self.format String Keyword file type, \"short\" (comma separated), \"fixed\" (standard PrePost format), or \"Long\" (double length PrePost format) self.range list[int] Start and end character index of the keyword self.comment Boolean Denotes whether the card string contains a comment line with the property names. self.length int Number of values set by the card. self.values list[int, float] List of all values in the card."},{"location":"cards/#methods","title":"Methods","text":""},{"location":"cards/#init","title":"init","text":"<p>Initialize a new Card object</p> <pre><code>class Card:\n    def __init__(self, input_string: str, input_range: list[int], format: str):\n\n#initialize from KeywordFile\nf=KeywordFile(\"/path/to.k\",\"fixed\")\nelastic_mat_mods=f.get_keywords(\"MAT_ELASTIC\")\ncard_one=elastic_mat_mods.get_card(0)\n\n#initialize independently\nk=Card(\"card string here\",[0,100],\"fixed\")\n</code></pre> <p>inputs</p> Attribute Type Description input_string String Ascii contents of the keyword format String Keyword file type, \"short\" (comma separated), \"fixed\" (standard PrePost format), or \"Long\" (double length PrePost format) input_range list[int] Start and end character index of the keyword <p>returns</p> <p>Keyword object</p>"},{"location":"cards/#info","title":"info","text":"<p>prints debugging information about the card</p> <pre><code>def info(self)\n\nf=KeywordFile(\"/path/to.k\",\"fixed\")\nelastic_mat_mods=f.get_keywords(\"MAT_ELASTIC\")\ncard_one=elastic_mat_mods.get_card(0)\ncard_one.info()\n\n&gt;&gt;Card Format: fixed\n&gt;&gt;Card comment included: False\n&gt;&gt;Card Range: [16,116]\n&gt;&gt;Card Length: 8\n&gt;&gt;Card Values: [0, 0, 0, 0, 0, 0, 0, 0]\n&gt;&gt;Card String: \"0       0       0       0       0       0       0       0\"\n</code></pre> <p>inputs</p> <p>None.</p> <p>returns</p> <p>Prints the card format, comment status, range, length, values, and string.</p>"},{"location":"cards/#edit","title":"edit","text":"<p>Change a value in the card</p> <pre><code>def edit(self, edit_index, edit_value):\n\nf=KeywordFile(\"/path/to.k\",\"fixed\")\nelastic_mat_mods=f.get_keywords(\"MAT_ELASTIC\")\ncard_one=elastic_mat_mods.get_card(0)\n\ncard_one.edit(0,1)\n\n</code></pre> <p>inputs</p> Attribute Type Description edit_index int Index of the card value to change edit_value int or float New value to insert <p>returns</p> <p>Updates card object and corresponding string.</p>"},{"location":"keyfile/","title":"Keyfile","text":"<p>The keyfile object contains and manages the contents of the entire LS-DYNA solver deck.  Methods for this object are used to extract subsets of interest for iteration, to replace values in the keyword deck, and to write subsequent iterations of the original file.</p>"},{"location":"keyfile/#attributes","title":"Attributes","text":"Attribute Type Description self.title String Keyword deck title (from *TITLE keyword) self.string String Ascii contents of the keyword file self.format String Keyword file type, \"short\" (comma separated), \"fixed\" (standard PrePost format), or \"Long\" (double length PrePost format) self.path String File path to .k file self.length int Number of ascii characters in the keyword file self.keywordcount int Number of keywords in the file self.keywordlocations list[int] List of the starting index of each keyword in the file"},{"location":"keyfile/#methods","title":"Methods","text":""},{"location":"keyfile/#init","title":"init","text":"<p>Initialize a new keyword file object from a file input</p> <pre><code>class KeywordFile:\n    def __init__(self, path, format):\n\n\nf=KeywordFile(\"/path/to.k\",\"fixed\")\n\n</code></pre> <p>inputs</p> Attribute Type Description path String Path to keyword file format String Keyword file type, \"short\" (comma separated), \"fixed\" (standard PrePost format), or \"Long\" (double length PrePost format) <p>returns</p> <p>KeywordFile object</p>"},{"location":"keyfile/#info","title":"info","text":"<p>prints debugging information about the keyword file</p> <pre><code>def info(self)\n\nf=KeywordFile(\"/path/to.k\",\"fixed\")\nf.info()\n\n&gt;&gt;Keyword file\n&gt;&gt;Title: LS-DYNA Keyword Input\n&gt;&gt;File length: 1000\n&gt;&gt;Number of keywords: 4\n&gt;&gt;Keyword locations: [10,52,100,516]\n\n</code></pre> <p>inputs</p> <p>None.</p> <p>returns</p> <p>Prints the keyword file name (*TITLE keyword), file length (# characters), number of individual keywords, and the location of the starting character of each keyword.</p>"},{"location":"keyfile/#get_keywords","title":"get_keywords","text":"<p>Retrieve all keywords of a specified type</p> <pre><code>def get_keywords(self, keyword_title):\n\nf=KeywordFile(\"/path/to.k\",\"short\")\n\nelastic_mat_mods=f.get_keywords(\"MAT_ELASTIC\")\n\n</code></pre> <p>inputs</p> Attribute Type Description keyword_title String keyword to search for, optional to include the \"*\" keyword delimeter <p>returns</p> <p>Returns Keyword object (one matching keyword found) or list of Keyword objects (multiple matching keywords found)</p>"},{"location":"keyfile/#get_nodes","title":"get_nodes","text":"<p>Create a Nodes object with all nodes in the keyword file</p> <pre><code>def get_nodes(self):\n\nf=KeywordFile(\"/path/to.k\",\"short\")\n\nf_nodes=f.get_nodes()\n\n</code></pre> <p>inputs</p> <p>None.</p> <p>returns</p> <p>Returns a Nodes object (special keyword type) with the node numbers and coordinates stored in numpy array format.</p>"},{"location":"keyfile/#get_elements","title":"get_elements","text":"<p>Create a Elements object with all elements of a specified type in the keyword file</p> <pre><code>def get_elements(self,eltype:str):\n\nf=KeywordFile(\"/path/to.k\",\"short\")\n\nf_solids=f.get_elements(\"SOLID\")\nf_quadraticsolids=f.get_elements(\"SOLID_T4TOT10\")\n\n</code></pre> <p>inputs</p> Attribute Type Description eltype String element keyword name to find, without \"ELEMENT_\" (e.g., \"SOLID\" for \"ELEMENT_SOLID\" keyword) returns <p>Returns a Elements object with the keyword file element connectivity table as a numpy array (self.array)</p>"},{"location":"keyfile/#get_set","title":"get_set","text":"<p>Create a Set object with all sets of a specified type in the keyword file</p> <pre><code>def get_elements(self,eltype:str):\n\nf=KeywordFile(\"/path/to.k\",\"short\")\n\nf_nodes=f.get_elements()\n\n</code></pre> <p>inputs</p> Attribute Type Description eltype String element keyword name to find, without \"SET_\" (e.g., \"NODE_LIST\" for \"SET_NODE_LIST\" keyword) returns <p>Returns a Set object (or list of set objects) with all sets of the specified type.</p>"},{"location":"keyfile/#replace_keyword","title":"replace_keyword","text":"<p>Replace an existing keyword in the solver deck with a new one.</p> <pre><code>def replace_keyword(self, keyword_to_replace):\n\nf=KeywordFile(\"/path/to.k\",\"short\")\n\nelastic_mat_mods=f.get_keywords(\"MAT_ELASTIC\")\n\nnew_mat_mod=elastic_mat_mods[0].edit_card(0,0,1)\n\nf.replace_keyword(new_mat_mod)\n\n</code></pre> <p>inputs</p> Attribute Type Description keyword_to_replace Keyword object Updated keyword containing the replacement context information <p>returns</p> <p>Updates the KeywordFile object string and keywordlocation information.</p>"},{"location":"keyfile/#replace_card","title":"replace_card","text":"<p>Replace an existing card in the solver deck with a new one.</p> <pre><code>def replace_keyword(self, card_to_replace):\n\nf=KeywordFile(\"/path/to.k\",\"short\")\n\nelastic_mat_mods=f.get_keywords(\"MAT_ELASTIC\")\n\nnew_mat_card_one=elastic_mat_mods[0].get_card\n\nnew_mat_card_one.edit(0,0,1)\n\nf.replace_card(new_mat_card_one)\n\n</code></pre> <p>inputs</p> Attribute Type Description card_to_replace Card object Updated Card containing the replacement context information <p>returns</p> <p>Updates the KeywordFile object string and keywordlocation information.</p>"},{"location":"keyfile/#write_keyfile","title":"write_keyfile","text":"<p>Writes a new keyword file output to the specified directory.</p> <pre><code>def write_keyfile(self, path):\n\nf=KeywordFile(\"/path/to.k\",\"short\")\n\nelastic_mat_mods=f.get_keywords(\"MAT_ELASTIC\")\n\nnew_mat_mod=elastic_mat_mods[0].edit_card(0,0,1)\n\nf.replace_keyword(new_mat_mod)\n\nf.write_keyfile(\"/path/to_new.k\")\n\n</code></pre> <p>inputs</p> Attribute Type Description path String File path to preferred output location <p>returns</p> <p>New .k file in specified directory.</p>"},{"location":"keyword/","title":"Keyword","text":"<p>The keyword object contains the data of a single keyword.  This includes all of the card objects associated with the keyword and its location in the corresponding solver deck.</p>"},{"location":"keyword/#attributes","title":"Attributes","text":"Attribute Type Description self.name String Keyword name self.string String Ascii contents of the keyword self.format String Keyword file type, \"short\" (comma separated), \"fixed\" (standard PrePost format), or \"Long\" (double length PrePost format) self.range list[int] Start and end character index of the keyword self.cardcount int Number of cards in the keyword self.cards list[Card] list containing each card in the keyword"},{"location":"keyword/#methods","title":"Methods","text":""},{"location":"keyword/#init","title":"init","text":"<p>Initialize a new keyword object</p> <pre><code>class Keyword:\n    def __init__(self, input_string, input_range, format):\n\n#initialize from KeywordFile\nf=KeywordFile(\"/path/to.k\",\"fixed\")\nelastic_mat_mods=f.get_keywords(\"MAT_ELASTIC\")\n\n#initialize independently\nk=Keyword(\"keyword string here\",[0,100],\"fixed\")\n</code></pre> <p>inputs</p> Attribute Type Description input_string String Ascii contents of the keyword format String Keyword file type, \"short\" (comma separated), \"fixed\" (standard PrePost format), or \"Long\" (double length PrePost format) input_range list[int] Start and end character index of the keyword <p>returns</p> <p>Keyword object</p>"},{"location":"keyword/#info","title":"info","text":"<p>prints debugging information about the keyword</p> <pre><code>def info(self)\n\nf=KeywordFile(\"/path/to.k\",\"fixed\")\nelastic_mat_mods=f.get_keywords(\"MAT_ELASTIC\")\nelastic_mat_mods.info()\n\n&gt;&gt;Keyword name: MAT_ELASTIC\n&gt;&gt;Keyword format: fixed\n&gt;&gt;Keyword range: [512,612]\n&gt;&gt;Keyword card count: 1\n&gt;&gt;Keyword cards: [...]\n&gt;&gt;Keyword string: \"*MAT_ELASTIC\\n...\"\n</code></pre> <p>inputs</p> <p>None.</p> <p>returns</p> <p>Prints the keyword name, keyword format, range, card count, cards, and keyword string.</p>"},{"location":"keyword/#get_card","title":"get_card","text":"<p>Retrieve a specified card from the keyword</p> <pre><code>def get_card(self, card_num):\n\nf=KeywordFile(\"/path/to.k\",\"short\")\n\nelastic_mat_mods=f.get_keywords(\"MAT_ELASTIC\")\n\nelastic_mat_mods_one=elastic_mat_mods.get_card(0)\n\n</code></pre> <p>inputs</p> Attribute Type Description card_num int Index of the card to return <p>returns</p> <p>Returns Card object.</p>"},{"location":"keyword/#replace_card","title":"replace_card","text":"<p>Replaces a selected card in the keyword with a new card object</p> <pre><code>def replace_card(self, card_num, card_replace):\n\nf=KeywordFile(\"/path/to.k\",\"short\")\n\nelastic_mat_mods=f.get_keywords(\"MAT_ELASTIC\")\n\nnew_card=Card(\"1,0,0,0,0\",[10,22],\"short\")\n\nelastic_mat_mods.replace_card(0,new_card)\n\n</code></pre> <p>inputs</p> Attribute Type Description card_num int Index of the card to return card_replace Card New card to insert <p>returns</p> <p>Updates the selected keyword to include a new card.</p>"},{"location":"transform/","title":"Transformation","text":"<p>An object which stores a 3d transformation matrix.  The matrix can be built through applying a sequential series of simple transformations (rotation, translation, scaling).  The resultant compound transformation can then be applied to a node set in the keyword file.</p>"},{"location":"transform/#attributes","title":"Attributes","text":"Attribute Type Description self.matrix np.ndarray 4x4 matrix containing the three-dimensional transformation operator"},{"location":"transform/#methods","title":"Methods","text":""},{"location":"transform/#init","title":"init","text":"<p>Initialize a new Card object</p> <pre><code>class Transformation:\n    def __init__(self):\n\ntransform_operator=Transformation()\n</code></pre> <p>inputs</p> <p>None.</p> <p>returns</p> <p>Transformation object containing a 4x4 identity matrix.</p>"},{"location":"transform/#scale","title":"Scale","text":"<p>Applies x,y,z scale factors to the transformation operator</p> <pre><code>def scale(self, sx, sy, sz):\n\ntransform_operator=Transformation()\n#scale by 2 in the x-direction\ntransform_operator.scale(2.0,1.0,1.0)\n\n</code></pre> <p>inputs</p> Attribute Type Description sx float x-direction scale factor sy float y-direction scale factor sz float z-direction scale factor <p>returns</p> <p>Updates self.matrix with the appropriate scaling operators.</p>"},{"location":"transform/#translate","title":"Translate","text":"<p>Applies x,y,z translation to the transformation operator.</p> <pre><code>def translate(self, tx, ty, tz):\n\ntransform_operator=Transformation()\n#shift by 2 in the x-direction\ntransform_operator.translate(2.0,0,0)\n\n</code></pre> <p>inputs</p> Attribute Type Description tx float x-direction translation ty float y-direction translation tz float z-direction translation <p>returns</p> <p>Updates self.matrix with the appropriate translation operators.</p>"},{"location":"transform/#rotate","title":"Rotate","text":"<p>Applies a rotation about an arbitrary axis, defined by two points in xyz space, to the transformation operator.</p> <pre><code>def rotate(self, p1, p2, angle):\n\ntransform_operator=Transformation()\n#rotate by 90 degrees about the x-axis\ntransform_operator.transform([0,0,0],[1.0,0,0],90)\n\n</code></pre> <p>inputs</p> Attribute Type Description p1 list[float] Point 1 for defining rotation axis p2 list[float] Point 2 for defining rotation axis angle float Angle (in degrees) to rotate the selected nodes about the defined axis <p>returns</p> <p>Updates self.matrix with the appropriate rotation operators.</p>"}]}